package pstore

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"time"

	"cloud.google.com/go/firestore"
	"github.com/dave/protod/delta"
	"github.com/dave/protod/perr"
	"github.com/dave/protod/pserver"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

type StateId string
type DocumentId string

// During an edit request we transform the operations in order that client and server both converge on the same value:
//
//       A (server & client) -> o
//                             / \
//                            /   \
//      op2 (from client) -> /     \ <- op1 (retrieved from the database)
//                          /       \
//                         /         \
//          C (client) -> o           o <- B (server)
//                         \         /
//                          \       /
//  op1x (send to client) -> \     / <- op2x (stored in the database)
//                            \   /
//                             \ /
//                              o <- D (server & client)
//
// The client and server are originally at [A]. The server has performed [op1] to arrive at [B], at the same time
// as the client was performing [op2] to arrive at [C]. We calculate [op1x] and [op2x] which both converge on [D].
// [op1x] is sent to the client, and [op2x] is stored in the database.
//
// Function parameters:
// stateId:      The unique id of this state record. This is generated by the client and resubmitted on retries.
// documentType: The fully qualified protobuf type name.
// documentId:   The unique id of the document.
// state:        The document state that client operations were performed against. Use 0 along with a set operation at the document root to add a new document.
// op2:          The client operation that was performed.
func Edit(ctx context.Context, s *pserver.Server, documentType string, documentId DocumentId, stateId StateId, state int64, op2 *delta.Op) (int64, *delta.Op, error) {

	t := s.Type(documentType)
	if t == nil {
		return 0, nil, fmt.Errorf("type %q not found", documentType)
	}

	ref := s.Firestore.Collection(t.CollectionName()).Doc(string(documentId))
	stateRef := ref.Collection(pserver.STATES_COLLECTION).Doc(string(stateId))

	if state == 0 && (op2 == nil || op2.Type != delta.Op_Set || op2.Location != nil) {
		return 0, nil, errors.New("if state is 0, op must be a single set operation with nil location")
	}

	if op2 == nil {
		// Just request an update (no need to store state)
		var ops []*delta.Op
		newState, err := s.Changes(ctx, nil, t, ref, state, 0, func(op *delta.Op) error {
			ops = append(ops, op)
			return nil
		})
		if err != nil {
			return 0, nil, err
		}
		return newState, delta.Compound(ops...), nil
	}

	var lastState, newState int64
	var op1x, op2x *delta.Op
	var duplicate *firestore.DocumentSnapshot

	f := func(ctx context.Context, tx *firestore.Transaction) error {

		// check for documents with the same unique request id
		documentExists, err := s.DocumentExists(ctx, tx, ref)
		if err != nil {
			return err
		}
		if !documentExists {

			if state != 0 {
				return errors.New("document didn't exist but edit operation supplied non zero state")
			}

			if t.OnAdd != nil {
				if err := t.OnAdd(ctx, s, tx, string(documentId)); err != nil {
					return err
				}
			}

			if newState, err = createDocument(ctx, s, tx, t, ref, stateRef, op2); err != nil {
				return err
			}

			return nil
		}

		duplicate, err = s.QueryState(ctx, tx, stateRef)
		if err != nil {
			return err
		}
		if duplicate != nil {
			// Exit from transaction and continue processing outside (no writes needed)
			return nil
		}

		if state == 0 {

			// For zero state, we don't need to transform because the operation will overwrite the entire document.

			lastState, err := s.Latest(ctx, tx, t, ref)
			if err != nil {
				return err
			}

			newState = lastState + 1

			opBlob, err := s.MarshalToBlob(op2)
			if err != nil {
				return err
			}

			stateItem, err := t.PackStateFunc(ctx, &pserver.State{State: newState, Op: opBlob})
			if err != nil {
				return err
			}

			if err := tx.Create(stateRef, stateItem); err != nil {
				return err
			}

			return nil
		}

		lastState, op1x, op2x, err = s.Transform(ctx, tx, t, ref, op2, state, 0)
		if err != nil {
			return err
		}

		// custom code
		if t.OnEdit != nil {
			if err := t.OnEdit(ctx, s, tx, string(documentId)); err != nil {
				return err
			}
		}

		// Increment the state
		newState = lastState + 1

		// Store op2x in the database
		op2xBlob, err := s.MarshalToBlob(op2x)
		if err != nil {
			return err
		}
		serverState := &pserver.State{State: newState, Op: op2xBlob}
		newStateItem, err := t.PackStateFunc(ctx, serverState)
		if err != nil {
			return err
		}

		if err := tx.Create(stateRef, newStateItem); err != nil {
			return err
		}

		return nil

	}
	tf := func() error {
		return s.Firestore.RunTransaction(s.FirestoreContext(ctx), f)
	}
	if err := pserver.Lock(ctx, ref.Path, tf); err != nil {
		return 0, nil, err
	}

	if duplicate == nil {
		return newState, op1x, nil
	}

	// This request has already been processed. We can recreate the correct response, and nothing needs to be
	// stored in the database.
	duplicateState, _, err := s.UnpackState(duplicate, t)
	if err != nil {
		return 0, nil, err
	}

	// Note that the state provided by the client is the "before" state for the transform, and the state from the
	// duplicate record is the "after" state in the transform:
	_, op1x, _, err = s.Transform(ctx, nil, t, ref, op2, state, duplicateState.State)
	if err != nil {
		return 0, nil, err
	}

	return duplicateState.State, op1x, nil

}

func Add(ctx context.Context, s *pserver.Server, documentType string, documentId DocumentId, stateId StateId, document proto.Message) (int64, error) {
	state, _, err := Edit(ctx, s, documentType, documentId, stateId, 0, delta.Root(document))
	return state, err
}

func createDocument(ctx context.Context, s *pserver.Server, tx *firestore.Transaction, t *pserver.DocumentType, ref, stateRef *firestore.DocumentRef, op2 *delta.Op) (int64, error) {

	if stateRef == nil {
		stateRef = ref.Collection(pserver.STATES_COLLECTION).Doc(string(NewStateID()))
	}

	document := t.NewDocument()
	documentBlob, err := s.MarshalToBlob(document)
	if err != nil {
		return 0, err
	}

	// if document doesn't exist, we add it
	snapshotItem, err := t.PackSnapshotFunc(ctx, &pserver.Snapshot{State: 0, Value: documentBlob}, nil, document)
	if err != nil {
		return 0, err
	}
	if err := tx.Create(ref, snapshotItem); err != nil {
		return 0, err
	}

	opBlob, err := s.MarshalToBlob(op2)
	if err != nil {
		return 0, err
	}
	newState := int64(1)
	stateItem, err := t.PackStateFunc(ctx, &pserver.State{State: newState, Op: opBlob})
	if err != nil {
		return 0, err
	}

	if err := tx.Create(stateRef, stateItem); err != nil {
		return 0, err
	}

	return newState, nil
}

func Get(ctx context.Context, s *pserver.Server, documentType string, documentId DocumentId, create bool) (int64, proto.Message, error) {

	t := s.Type(documentType)
	if t == nil {
		return 0, nil, fmt.Errorf("type %q not found", documentType)
	}

	// custom code
	if t.OnGet != nil {
		if err := t.OnGet(ctx, s, string(documentId)); err != nil {
			return 0, nil, err
		}
	}

	ref := s.Firestore.Collection(t.CollectionName()).Doc(string(documentId))

	var document proto.Message
	var data *pserver.Snapshot
	var added bool
	var state int64
	if !create {

		// if not create on missing, no need for transaction:
		var err error
		if document, data, _, err = s.UnpackSnapshot(ctx, nil, t, ref); err != nil {
			return 0, nil, err
		}

	} else {

		f := func(ctx context.Context, tx *firestore.Transaction) error {

			var err error
			document, data, _, err = s.UnpackSnapshot(ctx, tx, t, ref)
			switch {
			case status.Code(err) == codes.NotFound:
				added = true
				document = t.NewDocument()
				state, err = createDocument(ctx, s, tx, t, ref, nil, delta.Root(document))
				if err != nil {
					return err
				}
			case err != nil:
				return err
			}

			return nil
		}
		tf := func() error {
			return s.Firestore.RunTransaction(s.FirestoreContext(ctx), f)
		}
		if err := pserver.Lock(ctx, ref.Path, tf); err != nil {
			return 0, nil, err
		}

	}

	if !added {
		// this does not need to be inside the transaction, and is not needed if we
		// added a new record.
		var err error
		state, err = s.Changes(ctx, nil, t, ref, data.State, 0, func(op *delta.Op) error {
			if err := delta.Apply(op, document); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return 0, nil, err
		}
	}

	return state, document, nil
}

func Refresh(ctx context.Context, s *pserver.Server, documentType string, documentId DocumentId) error {

	t := s.Type(documentType)
	if t == nil {
		return fmt.Errorf("type %q not found", documentType)
	}

	ref := s.Firestore.Collection(t.CollectionName()).Doc(string(documentId))

	// Update the value snapshot. this doesn't need to be inside a transaction, because if the
	// snapshot is slightly out of date it doesn't matter.
	document, data, oldSnapshot, err := s.UnpackSnapshot(ctx, nil, t, ref)
	if err != nil {
		return perr.Wrap(err, "unpacking snapshot")
	}

	state, err := s.Changes(ctx, nil, t, ref, data.State, 0, func(op *delta.Op) error {
		if err := delta.Apply(op, document); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return err
	}
	if state == data.State {
		return nil
	}
	documentBlob, err := s.MarshalToBlob(document)
	if err != nil {
		return err
	}

	newData := &pserver.Snapshot{State: state, Value: documentBlob}
	newSnapshot, err := t.PackSnapshotFunc(ctx, newData, oldSnapshot, document)
	if err != nil {
		return err
	}
	if _, err := ref.Set(s.FirestoreContext(ctx), newSnapshot); err != nil {
		return err
	}
	return nil
}

func NewStateID() StateId {
	return StateId(uniqueID())
}

func NewDocumentID() DocumentId {
	return DocumentId(uniqueID())
}

var seededRand = rand.New(rand.NewSource(time.Now().UnixNano()))

func uniqueID() string {
	const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
	const length = 20
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return string(b)
}
