package pstore

import (
	"context"
	"fmt"
	"math/rand"
	"time"

	"cloud.google.com/go/firestore"
	"github.com/dave/protod/delta"
	"github.com/dave/protod/pserver"
	"google.golang.org/protobuf/proto"
)

// During an edit request we transform the operations in order that client and server both converge on the same value:
//
//       A (server & client) -> o
//                             / \
//                            /   \
//      op2 (from client) -> /     \ <- op1 (retrieved from the database)
//                          /       \
//                         /         \
//          C (client) -> o           o <- B (server)
//                         \         /
//                          \       /
//  op1x (send to client) -> \     / <- op2x (stored in the database)
//                            \   /
//                             \ /
//                              o <- D (server & client)
//
// The client and server are originally at [A]. The server has performed [op1] to arrive at [B], at the same time
// as the client was performing [op2] to arrive at [C]. We calculate [op1x] and [op2x] which both converge on [D].
// [op1x] is sent to the client, and [op2x] is stored in the database.
//
// Function parameters:
// stateId:    The unique id of this state record. This is generated by the client and resubmitted on retries.
// documentId: The unique id of the document.
// state:      The document state that client operations were performed against.
// op2:        The client operation that was performed.
func Edit(ctx context.Context, s *pserver.Server, t *pserver.DocumentType, stateId string, documentId string, state int64, op2 *delta.Op) (int64, *delta.Op, error) {

	// custom code
	if t.PreEdit != nil {
		if err := t.PreEdit(ctx, s, documentId); err != nil {
			return 0, nil, err
		}
	}

	ref := s.Firestore.Collection(t.CollectionName()).Doc(documentId)

	if op2 == nil {
		// Just request an update (no need to store state)
		var ops []*delta.Op
		newState, err := s.Changes(ctx, nil, t, ref, state, 0, func(op *delta.Op) error {
			ops = append(ops, op)
			return nil
		})
		if err != nil {
			return 0, nil, err
		}
		return newState, delta.Compound(ops...), nil
	}

	var lastState, newState int64
	var op1x, op2x *delta.Op
	var duplicate *firestore.DocumentSnapshot

	f := func(ctx context.Context, tx *firestore.Transaction) error {

		var err error
		duplicate, err = s.QueryState(ctx, tx, ref, stateId)
		if err != nil {
			return err
		}
		if duplicate != nil {
			// Exit from transaction and continue processing outside (no writes needed)
			return nil
		}

		lastState, op1x, op2x, err = s.Transform(ctx, tx, t, ref, op2, state, 0)
		if err != nil {
			return err
		}

		// custom code
		if t.OnEdit != nil {
			if err := t.OnEdit(ctx, s, tx, documentId); err != nil {
				return err
			}
		}

		// Increment the state
		newState = lastState + 1

		// Store op2x in the database
		op2xBlob, err := s.MarshalToBlob(op2x)
		if err != nil {
			return err
		}
		newStateRef := ref.Collection(pserver.STATES_COLLECTION).Doc(stateId)
		var newStateItem proto.Message
		serverState := &pserver.State{Id: stateId, State: newState, Op: op2xBlob}
		if t.PackState != nil {
			newStateItem, err = t.PackState(ctx, serverState)
			if err != nil {
				return err
			}
		} else {
			newStateItem = serverState
		}

		if err := tx.Create(newStateRef, newStateItem); err != nil {
			return err
		}

		return nil

	}
	tf := func() error {
		return s.Firestore.RunTransaction(s.FirestoreContext(ctx), f)
	}
	if err := pserver.Lock(ctx, ref.Path, tf); err != nil {
		return 0, nil, err
	}

	if duplicate == nil {
		return newState, op1x, nil
	}

	// This request has already been processed. We can recreate the correct response, and nothing needs to be
	// stored in the database.
	duplicateState, _, err := s.UnpackState(duplicate, t)
	if err != nil {
		return 0, nil, err
	}

	// Note that the state provided by the client is the "before" state for the transform, and the state from the
	// duplicate record is the "after" state in the transform:
	_, op1x, _, err = s.Transform(ctx, nil, t, ref, op2, state, duplicateState.State)
	if err != nil {
		return 0, nil, err
	}

	return duplicateState.State, op1x, nil

}

func Get(ctx context.Context, s *pserver.Server, t *pserver.DocumentType, id string) (int64, proto.Message, error) {

	ref := s.Firestore.Collection(t.CollectionName()).Doc(id)

	document, data, _, err := s.UnpackSnapshot(ctx, nil, t, ref)
	if err != nil {
		return 0, nil, err
	}

	state, err := s.Changes(ctx, nil, t, ref, data.State, 0, func(op *delta.Op) error {
		if err := delta.Apply(op, document); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return 0, nil, err
	}

	return state, document, nil
}

func Add(ctx context.Context, s *pserver.Server, t *pserver.DocumentType, id string, document proto.Message) error {

	// custom code
	if t.PreAdd != nil {
		if err := t.PreAdd(ctx, s, id); err != nil {
			return err
		}
	}

	ref := s.Firestore.Collection(t.CollectionName()).Doc(id)

	// do as much marshaling and unmarshaling as we can before opening the transaction
	opBlob, err := s.MarshalToBlob(delta.Set(nil, document))
	if err != nil {
		return err
	}
	docBlob, err := s.MarshalToBlob(document)
	if err != nil {
		return err
	}

	f := func(ctx context.Context, tx *firestore.Transaction) error {

		// check for documents with the same unique request id
		found, err := s.DocumentExists(ctx, tx, ref)
		if err != nil {
			return err
		}
		if found {
			return nil
		}

		// custom code
		if t.OnAdd != nil {
			if err := t.OnAdd(ctx, s, tx, id); err != nil {
				return err
			}
		}

		const initialState = 1

		var snapshot proto.Message
		snapshotData := &pserver.Snapshot{Id: id, State: initialState, Value: docBlob}
		if t.PackSnapshot != nil {
			snapshot, err = t.PackSnapshot(ctx, snapshotData, nil, document)
			if err != nil {
				return err
			}
		} else {
			snapshot = snapshotData
		}
		if err := tx.Create(ref, snapshot); err != nil {
			return err
		}

		stateId := uniqueID()
		stateRef := ref.Collection(pserver.STATES_COLLECTION).Doc(stateId)

		var state proto.Message
		stateData := &pserver.State{Id: stateId, State: initialState, Op: opBlob}
		if t.PackState != nil {
			state, err = t.PackState(ctx, stateData)
			if err != nil {
				return err
			}
		} else {
			state = stateData
		}

		if err := tx.Create(stateRef, state); err != nil {
			return err
		}

		return nil

	}
	if err := s.Firestore.RunTransaction(s.FirestoreContext(ctx), f); err != nil {
		return err
	}

	return nil
}

func Refresh(ctx context.Context, s *pserver.Server, t *pserver.DocumentType, id string) error {

	ref := s.Firestore.Collection(t.CollectionName()).Doc(id)

	// Update the value snapshot. this doesn't need to be inside a transaction, because if the
	// snapshot is slightly out of date it doesn't matter.
	document, data, oldSnapshot, err := s.UnpackSnapshot(ctx, nil, t, ref)
	if err != nil {
		return fmt.Errorf("unpacking snapshot: %w", err)
	}

	state, err := s.Changes(ctx, nil, t, ref, data.State, 0, func(op *delta.Op) error {
		if err := delta.Apply(op, document); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return err
	}
	if state == data.State {
		return nil
	}
	documentBlob, err := s.MarshalToBlob(document)
	if err != nil {
		return err
	}

	var newSnapshot proto.Message
	newData := &pserver.Snapshot{State: state, Value: documentBlob}
	if t.PackSnapshot != nil {
		newSnapshot, err = t.PackSnapshot(ctx, newData, oldSnapshot, document)
		if err != nil {
			return err
		}
	} else {
		newSnapshot = newData
	}
	if _, err := ref.Set(s.FirestoreContext(ctx), newSnapshot); err != nil {
		return err
	}
	return nil
}

const alphanum = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

func uniqueID() string {
	b := make([]byte, 20)
	if _, err := rand.Read(b); err != nil {
		panic(fmt.Sprintf("firestore: crypto/rand.Read error: %v", err))
	}
	for i, byt := range b {
		b[i] = alphanum[int(byt)%len(alphanum)]
	}
	return string(b)
}

func init() {
	rand.Seed(time.Now().UnixNano())
}
